# Lobby System Implementation Options

This document outlines multiple ways to implement a lobby system that creates a
world task per lobby and assigns random lobby IDs to players. Each option is
compatible with the current clean architecture and keeps an extension point for
future matchmaking.

## Option 1: In-Process Lobby Manager (Single Service)

Keep everything inside the Rust server. A `LobbyManager` owns a registry of
active lobbies and spawns one world task per lobby on demand.

Flow:

- Client connects to `/ws`.
- Client sends `Join { lobby_id }` or `JoinRandom`.
- `net.rs` asks `LobbyManager` for a lobby handle.
- `LobbyManager` creates a lobby (if missing) and starts a world task.
- Inputs route to that lobby, outputs broadcast only to that lobby.

Random lobby ID strategy:

- Generate a short base32/base64 ID (e.g., 6-8 chars) in `LobbyManager`.
- Guarantee uniqueness by checking the lobby registry before insertion.

Pros:

- Smallest surface area and lowest latency.
- No extra deployment or network hops.
- Simplest failure and observability story.

Cons:

- Matchmaking scalability tied to the game server process.
- Harder to share load across multiple server instances later.

## Option 2: External Matchmaking Service (Two Services)

Run a dedicated matchmaking service that allocates lobby IDs and returns a
target server or shard. The Rust server only manages lobbies within its own
process and trusts the assignment.

Flow:

- Client requests matchmaking from `matchmaking` service.
- Service returns `lobby_id` and `server_addr`.
- Client connects to `server_addr/ws` and sends `Join { lobby_id }`.
- Server spawns or joins the lobby world task.

Random lobby ID strategy:

- Generated by the matchmaking service with a globally unique ID.
- Server treats lobby IDs as opaque and does not mint them.

Pros:

- Clear scaling boundary and easier horizontal scaling.
- Matchmaking can evolve independently (regions, skill, queues).
- Game server stays focused on real-time simulation.

Cons:

- Additional network hop and new failure mode.
- Requires coordinated deployment and monitoring.

## Option 3: Hybrid (Pluggable Matchmaking Adapter)

Keep a local `LobbyManager`, but introduce an adapter layer that can source a
lobby assignment from either in-process logic or a remote service. The server
still owns world tasks per lobby, but the decision is abstracted.

Flow:

- Client connects to `/ws`.
- Client sends `JoinRandom`.
- `net.rs` calls a `MatchmakingProvider` trait.
- Provider returns `lobby_id` (local or remote assignment).
- `LobbyManager` creates or joins the lobby world task.

Random lobby ID strategy:

- Local provider: generate IDs and keep uniqueness in-process.
- Remote provider: accept externally issued IDs.
- Shared format ensures seamless switching between providers.

Pros:

- Minimal refactor when external matchmaking arrives.
- Keeps local development simple while enabling future scale-out.
- Lets you A/B local vs. remote matchmaking.

Cons:

- Slightly more abstraction up front.
- Two sources of truth to keep consistent in tests.

## Recommended Next Steps

If you want to move quickly now and keep a clean path to external matchmaking,
Option 3 is the safest default. It keeps the lobby manager authoritative for
world tasks while isolating the "assignment" decision behind a small interface.
